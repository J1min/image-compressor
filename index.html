<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>ì´ë¯¸ì§€ ì••ì¶•ê¸°</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 700px;
        margin: 2rem auto;
        padding: 1rem;
      }
      input[type="range"],
      input[type="number"],
      select {
        vertical-align: middle;
      }
      #fileList {
        list-style: none;
        padding: 0;
        margin-top: 1rem;
      }
      #fileList li {
        display: flex;
        align-items: center;
        margin-bottom: 0.8rem;
        border-bottom: 1px solid #ccc;
        padding-bottom: 0.5rem;
      }
      #fileList img {
        width: 80px;
        height: 80px;
        object-fit: contain;
        margin-right: 1rem;
        border: 1px solid #ddd;
      }
      #fileInfo {
        flex-grow: 1;
      }
      #summary {
        margin-top: 1rem;
        font-weight: bold;
      }
      button {
        margin-top: 1rem;
        padding: 0.6rem 1.2rem;
      }
      label {
        margin-right: 1rem;
      }
    </style>
  </head>
  <body>
    <h2>ì´ë¯¸ì§€ ì••ì¶•ê¸°</h2>

    <!-- í’ˆì§ˆ ì¡°ì ˆ -->
    <label>
      í’ˆì§ˆ ì¡°ì ˆ:
      <input
        type="range"
        id="qualityRange"
        min="0.1"
        max="1"
        step="0.1"
        value="0.7"
      />
      <span id="qualityValue">0.7</span>
    </label>

    <br /><br />

    <!-- í¬ê¸° ì¡°ì ˆ -->
    <label>
      ìµœëŒ€ ê°€ë¡œ:
      <input
        type="number"
        id="maxWidth"
        value="1024"
        min="1"
        style="width: 80px"
      />
    </label>
    <label>
      ìµœëŒ€ ì„¸ë¡œ:
      <input
        type="number"
        id="maxHeight"
        value="1024"
        min="1"
        style="width: 80px"
      />
    </label>
    <label>
      ë‹¨ìœ„:
      <select id="sizeUnit">
        <option value="px">px</option>
        <option value="%">%</option>
      </select>
    </label>

    <br /><br />

    <!-- ì˜µì…˜: ì›ë³¸ë³´ë‹¤ ì»¤ì§ˆ ê²½ìš° ê±´ë„ˆë›°ê¸° -->
    <label>
      <input type="checkbox" id="skipLarger" checked />
      ì›ë³¸ë³´ë‹¤ ìš©ëŸ‰ì´ ì»¤ì§ˆ ê²½ìš° ê±´ë„ˆë›°ê¸°
    </label>

    <br /><br />

    <input type="file" id="imageInput" multiple accept="image/*" />

    <ul id="fileList"></ul>
    <div id="summary"></div>

    <button id="downloadAllBtn" disabled>ğŸ“¥ ì „ì²´ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</button>
    <button id="saveFolderBtn">ğŸ“‚ í´ë”ì— ì €ì¥ (ì§€ì› ë¸Œë¼ìš°ì € í•œì •)</button>
  </body>

  <script>
    const qualityRange = document.getElementById("qualityRange");
    const qualityValue = document.getElementById("qualityValue");
    const imageInput = document.getElementById("imageInput");
    const fileList = document.getElementById("fileList");
    const summary = document.getElementById("summary");
    const downloadAllBtn = document.getElementById("downloadAllBtn");
    const saveFolderBtn = document.getElementById("saveFolderBtn");
    const sizeUnit = document.getElementById("sizeUnit");
    const maxWidthInput = document.getElementById("maxWidth");
    const maxHeightInput = document.getElementById("maxHeight");
    const skipLargerCheckbox = document.getElementById("skipLarger");

    let currentQuality = parseFloat(qualityRange.value);
    let compressedImages = [];
    let originalImages = [];

    // í’ˆì§ˆ ë³€ê²½ ì‹œ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    qualityRange.addEventListener("input", () => {
      currentQuality = parseFloat(qualityRange.value);
      qualityValue.textContent = currentQuality.toFixed(1);
      if (originalImages.length > 0) processImages();
    });

    // í¬ê¸° ë³€ê²½ ì‹œ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    maxWidthInput.addEventListener("input", () => {
      if (originalImages.length > 0) processImages();
    });
    maxHeightInput.addEventListener("input", () => {
      if (originalImages.length > 0) processImages();
    });

    // ë‹¨ìœ„ ë³€ê²½ ì‹œ ê°’ ë³€ê²½ + ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    sizeUnit.addEventListener("change", () => {
      if (sizeUnit.value === "%") {
        maxWidthInput.value = 100;
        maxHeightInput.value = 100;
      } else {
        maxWidthInput.value = 1024;
        maxHeightInput.value = 1024;
      }
      if (originalImages.length > 0) processImages();
    });

    // ì²´í¬ë°•ìŠ¤ ë³€ê²½ ì‹œ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
    skipLargerCheckbox.addEventListener("change", () => {
      if (originalImages.length > 0) processImages();
    });

    // íŒŒì¼ ì„ íƒ ì‹œ ì²˜ë¦¬
    imageInput.addEventListener("change", async (e) => {
      const files = Array.from(e.target.files || []);
      if (!files.length) return;
      originalImages = [];
      for (const file of files) {
        const dataUrl = await readFileAsDataURL(file);
        const img = await loadImage(dataUrl);
        originalImages.push({ img, name: file.name, size: file.size });
      }
      processImages();
    });

    // ì´ë¯¸ì§€ ì²˜ë¦¬
    async function processImages() {
      fileList.innerHTML = "";
      summary.textContent = "";
      compressedImages = [];

      let totalOriginal = 0;
      let totalCompressed = 0;

      for (const { img, name, size: originalSize } of originalImages) {
        totalOriginal += originalSize;
        try {
          let compressedBlob = await compressImage(img, currentQuality);

          // ê±´ë„ˆë›°ê¸° ì˜µì…˜ ì ìš©
          if (
            skipLargerCheckbox.checked &&
            compressedBlob.size > originalSize
          ) {
            compressedBlob = await fetch(img.src).then((r) => r.blob()); // ì›ë³¸ ê·¸ëŒ€ë¡œ
          }

          const compressedSize = compressedBlob.size;
          totalCompressed += compressedSize;

          compressedImages.push({ blob: compressedBlob, name });

          const li = document.createElement("li");
          const thumb = document.createElement("img");
          thumb.src = URL.createObjectURL(compressedBlob);
          thumb.alt = name;

          const info = document.createElement("div");
          info.id = "fileInfo";
          info.innerHTML = `
            <strong>${name}</strong><br/>
            ì›ë³¸ ìš©ëŸ‰: ${formatBytes(originalSize)}<br/>
            ì••ì¶• ìš©ëŸ‰: ${formatBytes(compressedSize)}<br/>
            ì••ì¶•ë¥ : ${compressionRate(originalSize, compressedSize)}% â†“
          `;

          li.appendChild(thumb);
          li.appendChild(info);
          fileList.appendChild(li);
        } catch (err) {
          console.error("ì••ì¶• ì‹¤íŒ¨:", err);
        }
      }

      summary.textContent = `ì´í•©: ${formatBytes(
        totalOriginal
      )} â†’ ${formatBytes(totalCompressed)} (${compressionRate(
        totalOriginal,
        totalCompressed
      )}% â†“)`;
      downloadAllBtn.disabled = compressedImages.length === 0;
    }

    // ë‹¤ìš´ë¡œë“œ
    downloadAllBtn.addEventListener("click", () => {
      compressedImages.forEach(({ blob, name }) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `compressed_${name}`;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(url);
        a.remove();
      });
    });

    // í´ë” ì €ì¥
    saveFolderBtn.addEventListener("click", async () => {
      if (!window.showDirectoryPicker) {
        alert("ì´ ë¸Œë¼ìš°ì €ëŠ” í´ë” ì„ íƒ ì €ì¥ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
        return;
      }
      try {
        const dirHandle = await window.showDirectoryPicker();
        for (const { blob, name } of compressedImages) {
          const fileHandle = await dirHandle.getFileHandle(
            `compressed_${name}`,
            { create: true }
          );
          const writable = await fileHandle.createWritable();
          await writable.write(blob);
          await writable.close();
        }
        alert("í´ë”ì— ì €ì¥ ì™„ë£Œ!");
      } catch (err) {
        alert("ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ");
        console.error(err);
      }
    });

    // í—¬í¼
    function readFileAsDataURL(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () =>
          typeof reader.result === "string"
            ? resolve(reader.result)
            : reject(new Error("Invalid data URL"));
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function compressImage(image, quality) {
      return new Promise((resolve, reject) => {
        const unit = sizeUnit.value;
        const maxW = parseFloat(maxWidthInput.value);
        const maxH = parseFloat(maxHeightInput.value);

        let targetW, targetH;
        if (unit === "px") {
          targetW = maxW || image.width;
          targetH = maxH || image.height;
        } else {
          targetW = Math.round(image.width * (maxW / 100));
          targetH = Math.round(image.height * (maxH / 100));
        }

        const ratio = Math.min(
          targetW / image.width,
          targetH / image.height,
          1
        );
        const width = Math.round(image.width * ratio);
        const height = Math.round(image.height * ratio);

        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        if (!ctx) return reject(new Error("Canvas not supported"));

        ctx.drawImage(image, 0, 0, width, height);
        canvas.toBlob(
          (blob) => (blob ? resolve(blob) : reject(new Error("ì••ì¶• ì‹¤íŒ¨"))),
          "image/webp",
          quality
        );
      });
    }

    function formatBytes(bytes) {
      const units = ["B", "KB", "MB"];
      let i = 0;
      while (bytes >= 1024 && i < units.length - 1) {
        bytes /= 1024;
        i++;
      }
      return `${bytes.toFixed(1)} ${units[i]}`;
    }

    function compressionRate(original, compressed) {
      return Math.round((1 - compressed / original) * 100);
    }
  </script>
</html>
